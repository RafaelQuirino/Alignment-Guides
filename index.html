<!doctype html>
<title>Alignment Guides</title>
<style>
  html {
    -webkit-user-select: none;
       -moz-user-select: none;
        -ms-user-select: none;
         -o-user-select: none;
            user-select: none;
  }
  h1 {
    font: normal 34px/300px sans-serif;
    text-align: center;
    color: #ccc;
  }
  .box { 
    background: hsl(205,100%,90%);
    border: 1px solid hsl(205,100%,80%);
    position: absolute;
    box-sizing: border-box;
    -moz-box-sizing: border-box;
  }
  .selected {
    z-index: 1;
    background-color: hsl(205,100%,80%);
    border-color: hsl(205,100%,70%);
  }
  .guide {
    left: 0;
    top: 0;
    position: absolute;
    background: hsl(205,100%,75%);
    z-index: 2;
  }
  .guide.static {
    background: rgba(0,0,0,0);
  }
  .guide.direction-x {
    height: 100%;
    width: 1px;
  }
  .guide.direction-y {
    height: 1px;
    width: 100%;
  }
  pre {
    position: absolute;
    left: 13px;
    top: 13px;
    z-index: 3;
  }
</style>
<h1>Draw and Move with your Mouse</h1>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script>
  // touch feature detection from modernizr.js
  var HASTOUCH = ('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch ? true : false;
  var INPUTDOWN, INPUTMOVE, INPUTUP;

  if (HASTOUCH) {
  	INPUTDOWN = "touchstart";
  	INPUTMOVE = "touchmove";
  	INPUTUP = "touchend";
  } else {
  	INPUTDOWN = "mousedown";
  	INPUTMOVE = "mousemove";
  	INPUTUP = "mouseup";
  }

  function normalizedX(event){
  	return HASTOUCH ? event.originalEvent.touches[0].pageX : event.pageX;
  }	

  function normalizedY(event){
  	return HASTOUCH ? event.originalEvent.touches[0].pageY : event.pageY;
  }
  
  /* small visuall debug console for mobile */
  var pre = $('<pre>').appendTo($('html'));
  function debug(){
    pre[0].innerHTML += JSON.stringify( [].slice.call(arguments, 0) ) +"\n";
  }
  
  // Array Remove one occurence of the given entry
  Array.prototype.removeEntry = function(entry){
    var index = this.indexOf(entry);
    if(index !== -1) this.remove(index);
  };
  
  // Array Remove - By John Resig (MIT Licensed)
  Array.prototype.remove = function(from, to) {
    var rest = this.slice((to || from) + 1 || this.length);
    this.length = from < 0 ? this.length + from : from;
    return this.push.apply(this, rest);
  };
  
  function drawArea(){
    this.boxes = new Array();
    this.snapTreshhold = 5;
    this.edges = { 
      x : new Array(),
      y : new Array()
    };
    
    $(document).bind(INPUTDOWN, this.startToDraw.bind(this));
    $(document).bind('boxMoveEnd', this.chart.bind(this));
    $(document).bind('boxMoveEnd', this.removeGuides.bind(this));
  }
  
  drawArea.prototype = {
    startToDraw : function(event){
      
      var box = new Box(this);
      box.start(event);
      this.boxes.push(box);
    
      $(document).bind(INPUTMOVE, box.update.bind(box));
      debug("bind", INPUTUP);
      $(document).one(INPUTUP, this.finishDrawing.bind(this));
    },
    finishDrawing : function(event){
      this.boxes[ this.boxes.length-1 ].seal();
      $(document).unbind(INPUTMOVE);
    },
    chart : function(){
      this.edges = { 
        x : new Array(),
        y : new Array()
      };
      
      for(var i=0; i<this.boxes.length; i++){
        var box = this.boxes[i];
        
        this.edges.x.push(box.pos.x, box.pos.x + Math.round(box.width/2), box.pos.x + box.width);
        this.edges.y.push(box.pos.y, box.pos.y + Math.round(box.height/2), box.pos.y + box.height);
      }
      
      this.showAllGuides();
    },
    removeGuides : function(){
      $('.guide:not(.static)').remove();
    },
    addGuide : function(direction, position, additionalClass){
      var className = 'direction-' + direction;
      if(additionalClass) className += " " + additionalClass;
      
      $('html').append( 
        $('<div class="guide">')
          .addClass(className)
          .css(direction === 'x' ? 'left' : 'top', position)
      );
    },
    showAllGuides : function(){
      $('.guide.static').remove();
      this.drawStaticGuides('x');
      this.drawStaticGuides('y');
    },
    drawStaticGuides : function(direction){
      for(var i=0; i<this.edges[direction].length; i++){
        this.addGuide(direction, this.edges[direction][i], 'static');
      }
    }
  };
  
  
  function Box(parent){
    this.parent = parent;
    this.pos = {
      x : 0,
      y : 0
    };
    this.el = $('<div class="box">');
  }
  
  Box.prototype = {
    start : function(event){
      this.startPos = { x: normalizedX(event), y: normalizedY(event) };
      
      this.pos.x = this.startPos.x;
      this.pos.y = this.startPos.y;
      
      this.el.css({ left: this.pos.x, top: this.pos.y });
      $('html').append(this.el);
      
      this.select();
      this.update(event);
    },
    update : function(event){
      var mouseX = normalizedX(event);
      var mouseY = normalizedY(event);
      debug(mouseX, mouseY);
      
      this.width = Math.abs(mouseX - this.startPos.x);
      this.height = Math.abs(mouseY - this.startPos.y);
      
      if(mouseX < this.startPos.x)
        this.pos.x = mouseX;
      else
        this.pos.x = this.startPos.x;
      
      if(mouseY < this.startPos.y)
        this.pos.y = mouseY;
      else
        this.pos.y = this.startPos.y;
        
      this.snapToGuides(true);
      
      this.el.css({
        left: this.pos.x,
        top: this.pos.y,
        width: this.width,
        height: this.height
      });
    },
    select : function(){
      this.el.addClass('selected').siblings().removeClass('selected');
    },
    seal : function(){
      debug("seal - bind", INPUTDOWN);
      this.el.bind(INPUTDOWN, this.startToDrag.bind(this));
      $(document).trigger('boxMoveEnd');
    },
    startToDrag : function(event){
      event.stopPropagation();
      this.mouseOffset = {
        x : normalizedX(event) - this.el.offset().left,
        y : normalizedY(event) - this.el.offset().top
      };
      
      $(document).bind(INPUTMOVE, this.drag.bind(this));
      $(document).bind(INPUTUP, this.stopToDrag);
      
      this.removeBoxEdgesFromGuideSet('x');
      this.removeBoxEdgesFromGuideSet('y');
      this.parent.showAllGuides();
      
      this.select();
      this.drag(event);
    },
    drag : function(event){
      var mouseX = normalizedX(event);
      var mouseY = normalizedY(event);
      
      this.pos.x = mouseX - this.mouseOffset.x;
      this.pos.y = mouseY - this.mouseOffset.y;
      
      this.snapToGuides();
      
      this.el.css({ left: this.pos.x, top: this.pos.y });
    },
    stopToDrag : function(event){
      $(document).unbind(INPUTMOVE);
      $(document).trigger('boxMoveEnd');
    },
    snapToGuides : function(resizing){
      this.parent.removeGuides();
      this.snap('x', resizing);
      this.snap('y', resizing);
    },
    removeBoxEdgesFromGuideSet : function(direction){
      var side = direction === 'x' ? 'width' : 'height';
      var position = this.pos[direction];
      
      this.parent.edges[direction].removeEntry( position );
      this.parent.edges[direction].removeEntry( position + Math.round(this[side]/2) );
      this.parent.edges[direction].removeEntry( position + this[side] );
    },
    /*
      snap
      ====
      
      TODO: - differentiate between drag and resize - for resize we have to adopt width and height
    */
    snap : function(direction, resizing){
      var side = direction === 'x' ? 'width' : 'height';
      
      for(var i=0; i<this.parent.edges[direction].length; i++){
        var position = this.parent.edges[direction][i];
        var distance = this.pos[direction];
        var halfSideLength = Math.abs(this[side]/2);
        var centerDistance = distance + halfSideLength;
        var endDistance = distance + this[side];
        var setGuide = false;
        
        if(Math.abs(distance - position) <= this.parent.snapTreshhold){
          this.pos[direction] = position;
          setGuide = true;
        }
        else if(Math.abs(centerDistance - position) <= this.parent.snapTreshhold){
          if(resizing)
            this[side] = Math.round(Math.abs(position - distance)*2);
          else
            this.pos[direction] = position - halfSideLength;
          setGuide = true;
        }
        else if(Math.abs(endDistance - position) <= this.parent.snapTreshhold){
          if(resizing)
            this[side] = Math.abs(position - distance);
          else
            this.pos[direction] = position - this[side];
          setGuide = true;
        }
        
        if(setGuide)
          this.parent.addGuide(direction, position);
      }
    }
  };
  
  area = new drawArea();
</script>